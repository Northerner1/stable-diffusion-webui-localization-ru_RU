// наведите курсор на всплывающие подсказки для различных элементов пользовательского интерфейса

var titles = {
    "Sampling steps": "Сколько раз циклически улучшать сгенерированное изображение; более высокие значения требуют больше времени; очень низкие значения могут привести к плохим результатам",
    "Sampling method": "Какой алгоритм использовать для создания изображения",
    "GFPGAN": "Восстановление лиц низкого качества с помощью нейронной сети GFPGAN",
    "Euler a": "Euler Ancestral - очень креативно, у каждого может получиться совершенно разная картинка в зависимости от количества шагов, установка шагов выше 30-40 не помогает",
    "DDIM": "Неявные модели шумоподавления диффузии - лучше всего в рисовании",
    "UniPC": "Унифицированная структура предиктора-корректора для быстрой семплинга диффузионных моделей",
    "DPM adaptive": "Игнорирует количество шагов — использует количество шагов, определяемое CFG и разрешением",

    "\u{1F4D0}": "Автоматическое определение размера из изо-в-изо",
    "Batch count": "Сколько партий изображений нужно создать (не влияет на производительность генерации или использование видеопамяти)",
    "Batch size": "Сколько изображений создавать в одной партии (увеличивает производительность генерации за счет более высокого использования видеопамяти)",
    "CFG Scale": "Шкала свободного наведения классификатора - насколько сильно изображение должно соответствовать промпту - меньшие значения дают более творческие результаты",
    "Seed": "Значение, определяющее случайность чисел зерна - если вы создадите изображение с теми же параметрами и зерном, вы получите тот же результат",
    "\u{1f3b2}\ufe0f": "Установить значение в -1, что приведет к созданию каждого случайного нового зерна.",
    "\u267b\ufe0f": "Повторное использование зерна из прошлой генерации. В основном полезно, если оно было случайным",
    "\u2199\ufe0f": "Вставить промпт предыдущей генерации (окно промпта должно быть пустым)",
    "\u{1f4c2}": "Открыть директория вывода изображений",
    "\u{1f4be}": "Сохранить стиль",
    "\u{1f5d1}\ufe0f": "Очистить промпт",
    "\u{1f4cb}": "Применить выбранные стили к текущему промту",
    "\u{1f4d2}": "Вставьте доступные значения в поле",
    "\u{1f3b4}": "Показать/скрыть доп. сети",
    "\u{1f300}": "Восстановить прогресс",

    "Inpaint a part of image": "Нарисуйте маску поверх изображения, и скрипт перегенерирует замаскированную область в соответствии с промптом",
    "SD upscale": "Обычное увеличение изображения, разделение результата на тайлы, улучшение каждого тайла с помощью изо-в-изо, после объединение всего изображения обратно",

    "Just resize": "Изменит размер изображения в соответствии с целевым разрешением. Если высота и ширина не совпадают, вы получите неправильное соотношение сторон.",
    "Crop and resize": "Изменит размер изображения так, чтобы оно полностью заполнило выбранное разрешение. Обрежет торчащие части.",
    "Resize and fill": "Изменит размер изображения так, чтобы все изображение было в пределах целевого разрешения. Заполнит пустое пространство цветами изображения.",

    "Mask blur": "Насколько сильно нужно размыть маску перед обработкой, в пикселях.",
    "Masked content": "Что поместить внутрь маскированной области перед обработкой с помощью Stable Diffusion.",
    "fill": "заполнить с учётом цветов изображения",
    "original": "сохранить все, что там было изначально",
    "latent noise": "Заполните его скрытым пространственным шумом",
    "latent nothing": "Заполните его скрытыми нулями",
    "Inpaint at full resolution": "Апскейл маскированной области до указанного разрешения, выполнение Перерисовки, обратное уменьшение масштаба и вставка в исходное изображение",

    "Denoising strength": "Определяет, насколько мало алгоритм соответствует содержимому изображения. При значении 0 ничего не изменится, а при значении 1 вы получите несвязанное изображение. При значениях меньше 1.0 обработка займет меньше шагов, чем задано ползунком \"Шаги\".",
    
    "Skip": "Пропустить генерацию текущего изображения и продолжить генерировать следующее изображение.",
    "Interrupt": "Остановить генерацию изображений и показать результат на данный момент генерации.",
    "Save": "Сохранение изображения в директорию (по умолчанию - log/images) и параметров генерации в файл csv.",

    "X values": "Разделите значения для оси X запятыми.",
    "Y values": "Разделите значения для оси Y запятыми.",

    "None": "Ничего не делает",
    "Prompt matrix": "Разделите промт на части с помощью вертикального символа (|), и скрипт создаст картинку для каждой их комбинации (кроме первой части, которая будет присутствовать во всех комбинациях)",
    "X/Y/Z plot": "Создайте сетку(-ки), в которой(-ых) изображения будут иметь различные параметры. Используйте приведенные ниже окна, чтобы указать, какие параметры будут общими для столбцов и строк",
    "Custom code": "Запуск кода Python. Только для опытных пользователей. Для работы программы необходимо прописать в webui-user.bat - 'COMMANDLINE_ARGS=' --allow-code",

    "Prompt S/R": "Выделите список слов запятыми, и первое слово будет использоваться в качестве ключевого слова: скрипт будет искать это слово в промте и заменять его другим",
    "Prompt order": "Выделите список слов запятыми, и скрипт создаст вариацию промпта с этими словами для всех возможных порядков их следования",

    "Tiling": "Создайте бесшовное изображение(текстуру).",
    "Tile overlap": "Для SD-апскейла - сколько пикселей должно быть перекрыто между тайлами. Тайлы перекрываются таким образом, чтобы при объединении их в одно изображение не было хорошо заметного шва.",

    "Variation seed": "зёрна другого изображения будут перемешаниваться в генерации",
    "Variation strength": "Насколько сильное изменение нужно произвести. При 0 эффекта не будет. При 1 вы получите полную картину с вариацией зерен (за исключением наследуемых семплеров, где вы просто получите что-нибудь).",
    "Resize seed from height": "Попытайтесь получить изображение, аналогичное тому, которое было бы получено при использовании того же зерна с заданной высотой",
    "Resize seed from width": "Попытайтесь получить изображение, аналогичное тому, которое было бы получено при использовании того же зерна с заданной шириной",

    "Interrogate": "Реконструирует (создаёт) промпт из последнего изображения и помещает его в окно позитивного промпта.",

    "Images filename pattern": "Используйте следующие теги, чтобы определить, как выбираются имена файлов для изображений: [steps], [cfg], [prompt_hash], [prompt], [prompt_no_styles], [prompt_spaces], [width], [height], [styles], [sampler], [seed], [model_hash], [model_name], [prompt_words], [date], [datetime], [datetime<Format>], [datetime<Format><Time Zone>], [job_timestamp]; пустое по умолчанию",
    "Directory name pattern": "Используйте следующие теги, чтобы определить, как выбираются субдиректории для изображений и сеток: [steps], [cfg],[prompt_hash], [prompt], [prompt_no_styles], [prompt_spaces], [width], [height], [styles], [sampler], [seed], [model_hash], [model_name], [prompt_words], [date], [datetime], [datetime<Format>], [datetime<Format><Time Zone>], [job_timestamp]; пустое по умолчанию",
    "Max prompt words": "Установите максимальное количество слов, которые будут использоваться в опции [prompt_words]; ВНИМАНИЕ: Если слова слишком длинные, они могут превысить максимальную длину пути к файлу, которую может обработать система.",

    "Loopback": "Выполняет обработку изо-в-изо несколько раз. Полученные изображения используются в качестве входных данных для следующего цикла.",
    "Loops": "Сколько раз обрабатывать изображение. Каждый выход используется как вход следующего цикла. Если установить значение 1, поведение будет таким, как если бы этот скрипт не использовался.",
    "Final denoising strength": "Сила шумоподавления для конечного цикла каждого изображения в партии.",
    "Denoising strength curve": "Кривая шумоподавления контролирует скорость изменения силы шумоподавления в каждом цикле. Агрессивная: Большая часть изменений будет происходить в начале циклов. Линейная: Изменения будут постоянными на протяжении всех циклов. Ленивая: Большая часть изменений будет происходить к концу циклов.",

    "Style 1": "Стиль для применения; стили имеют компоненты для позитивных и негативных промтов и применяются к обоим стилям",
    "Style 2": "Стиль для применения; стили имеют компоненты для позитивных и негативных промтов и применяются к обоим стилям",
    "Apply style": "Применить выбранные стили в поля промпта",
    "Create style": "Сохраните текущий промпт как стиль. Если вы добавите в текст маркер {prompt}, стиль будет использовать его в качестве заполнителя для вашего промпта, когда вы будете использовать стиль в будущем.",

    "Checkpoint name": "Загружает веса из модели перед созданием изображений. В качестве имени модели можно использовать хэш или часть имени файла (как показано в настройках). Рекомендуется использовать с осью Y для меньшего переключения.",
    "Inpainting conditioning mask strength": "Применяется только к моделям для перерисовки. Определяет, насколько сильно маскировать исходное изображение для перерисовки и изо-в-изо. 1.0 означает полную маскировку (значение по умолчанию). 0.0 означает полностью незамаскированное состояние. Более низкие значения помогут сохранить общую композицию изображения, но будет тупить при больших изменениях.",

    "vram": "Пиковый объем видеопамяти, используемый Torch во время генерации, без учета кэшированных данных.\nTorch reserved: Пиковый объем видеопамяти, выделенный Torch, включая все активные и кэшированные данные.\nSys VRAM: Пиковый объем видеопамяти, выделенный всем приложениям / общий объем VRAM GPU (пиковое использование в %).",

    "Eta noise seed delta": "Если это значение ненулевое, оно будет добавлено к зерну и использовано для инициализации RNG для шумов при использовании сэмплеров с Eta. Вы можете использовать это для получения еще большего разнообразия изображений, или для подбора изображений из других программ, если вы знаете, что делаете.",

    "Filename word regex": "Это регулярное выражение будет использоваться для извлечения слов из имени файла, и они будут объединены с помощью опции ниже в текст метки, используемый для обучения. Оставьте пустым, чтобы оставить текст имени файла как есть.",
    "Filename join string": "Эта строка будет использоваться для объединения разделенных слов в одну строку, если включена опция выше.",

    "Quicksettings list": "Список имен настроек, разделенных запятыми, для настроек, которые должны попасть на панель быстрого доступа вверху, а не на обычную вкладку настроек. См. modules/shared.py для настройки имен. Для применения требуется перезагрузка.",

    "Weighted sum": "Результат = A * (1 - M) + B * M",
    "Add difference": "Результат = A + (B - C) * M",
    "No interpolation": "Результат = A",

    "Initialization text": "Если количество токенов больше, чем количество векторов, некоторые из них могут быть пропущены.\nОставьте текстовое поле пустым, чтобы начать с обнуленных векторов.",
    "Learning rate": "Как быстро должно проходить обучение. Низкие значения требуют больше времени для обучения, высокие значения могут не сходиться (не генерировать точные результаты) и/или могут сломать встраивание (Это произошло, если вы видите Loss: nan в текстовом поле информации об обучении. Если это произошло, вам нужно вручную восстановить встраивание из более старой резервной копии, не сломанной).\n\nВы можете задать одно числовое значение или несколько скоростей обучения, используя синтаксис:\n\n  rate_1:max_steps_1, rate_2:max_steps_2, .... ...\n\nEG:  0.005:100, 1e-3:1000, 1e-5\n\n\nБудет обучаться со скоростью 0.005 для первых 100 шагов, затем 1e-3 до 1000 шагов, затем 1e-5 для всех оставшихся шагов.",

    "Clip skip": "Параметр ранней остановки для CLIP модели; 1 - остановка на последнем слое, как обычно, 2 - остановка на предпоследнем слое и т.д.",

    "Approx NN": "Дешевая аппроксимация нейронной сетью. Очень быстрая по сравнению с VAE, но дает изображения в 4 раза с меньшим разрешением по горизонтали/вертикали и более низким качеством.",
    "Approx cheap": "Очень дешевая аппроксимация. Очень быстрое по сравнению с VAE, но дает изображения в 8 раз с меньшим разрешением по горизонтали/вертикали и крайне низким качеством.",

    "Hires. fix": "Используйте двухэтапный процесс для частичного создания изображения с меньшим разрешением, увеличения масштаба, а затем улучшения деталей на нем без изменения композиции",
    "Hires steps": "Количество шагов для апскейльнутого изображения. Если 0, используется то же, что и для оригинала.",
    "Upscale by": "Регулирует размер изображения путем умножения исходной ширины и высоты на выбранное значение. Игнорируется, если значения 'Изменить ширину до' или 'Изменить высоту до' не равны нулю.",
    "Resize width to": "Изменяет размер изображения до данной ширины. Если 0, ширина определяется по одному из двух соседних ползунков.",
    "Resize height to": "Изменяет размер изображения до данной высоты. Если 0, высота определяется по одному из двух соседних ползунков.",
    "Multiplier for extra networks": "При добавлении дополнительной сети, такой как Гиперсеть или Lora, используйте для нее этот множитель.",
    "Discard weights with matching name": "Регулярное выражение; если вес имени совпадает с ним, то вес не записываются в результирующую модель. Используйте ^model_ema для отбрасывания EMA весов.",
    "Extra networks tab order": "Список имен вкладок, разделенных запятыми; перечисленные здесь вкладки будут отображаться в пользовательском интерфейсе extra networks первыми и в порядке перечисления.",
    "Negative Guidance minimum sigma": "Пропуск негативного промта для шагов, где изображение уже в основном очищено от шума; чем выше это значение, тем больше будет пропусков; обеспечивает повышенную производительность в обмен на небольшое снижение качества."
}

function updateTooltipForSpan(span) {
    if (span.title) return; // already has a title

    let tooltip = localization[titles[span.textContent]] || titles[span.textContent];

    if (!tooltip) {
        tooltip = localization[titles[span.value]] || titles[span.value];
    }

    if (!tooltip) {
        for (const c of span.classList) {
            if (c in titles) {
                tooltip = localization[titles[c]] || titles[c];
                break;
            }
        }
    }

    if (tooltip) {
        span.title = tooltip;
    }
}

function updateTooltipForSelect(select) {
    if (select.onchange != null) return;

    select.onchange = function() {
        select.title = localization[titles[select.value]] || titles[select.value] || "";
    };
}

var observedTooltipElements = {SPAN: 1, BUTTON: 1, SELECT: 1, P: 1};

onUiUpdate(function(m) {
    m.forEach(function(record) {
        record.addedNodes.forEach(function(node) {
            if (observedTooltipElements[node.tagName]) {
                updateTooltipForSpan(node);
            }
            if (node.tagName == "SELECT") {
                updateTooltipForSelect(node);
            }

            if (node.querySelectorAll) {
                node.querySelectorAll('span, button, select, p').forEach(updateTooltipForSpan);
                node.querySelectorAll('select').forEach(updateTooltipForSelect);
            }
        });
    });
});
